local pkg = {["os"]={["CraftOS"]={["name.grub"]="CraftOS Shell!@#&The default ComputerCraft OS.",["startup"]="if lgrub.enabled then!@#&  lgrub.bootNewOS('CraftOS') -- CraftOS handling is hard-coded!@#&  return!@#&else!@#&  printError('LuaGRUB not found')!@#&  sleep(4)!@#&  os.shutdown()!@#&end",},},["README.md"]="LuaGRUB!@#&=======!@#&A GRUB-like bootloader for ComputerCraft!@#&!@#&Features:!@#&- Select between multiple OSes on a single computer.!@#&- OSes can reboot into another OS (even CraftOS), if they support it.!@#&- Use no global variables.!@#&!@#&Planned:!@#&- Lie to OSes so they think they are in the root folder, so OSes with absolute paths will not require recoding.!@#&- Support scrolling.!@#&- Support persistent OS selections. (A new OS can already be chosen, but currently the OS must not reboot for the decision to have any effect.)!@#&- Automated installer/updater",["startup"]="local __GRUB_START_TIME = nil -- Initialized just before the main loop/timer are run!@#&local __GRUB_COUNTDOWN_TIME = 15!@#&local __GRUB_TIME_LEFT = __GRUB_COUNTDOWN_TIME!@#&local __GRUB_RUN_TIME = nil -- calculated as os.clock - __GRUB_START_TIME!@#&!@#&function loadAPI(path) -- Thanks to theoriginalbit for this loadAPI replacer!@#&  local name = string.match(fs.getName(path), '(%a+)%.?.-')!@#&  local env = setmetatable({shell = shell}, { __index = _G }) -- passes a ref of the shell api to the loaded api!@#&  local func, err = loadfile(path)!@#&  if not func then!@#&    return false, printError(err)!@#&  end!@#&  setfenv(func, env)!@#&  func()!@#&  local api = {}!@#&  for k,v in pairs(env) do!@#&    api[k] = v!@#&  end!@#&  _G[name] = api!@#&  return true!@#&end!@#&!@#&-- init!@#&local __tempPEStorage = os.pullEvent!@#&os.pullEvent = os.pullEventRaw -- Prevent ctrl-T!@#&local h, w = term.getSize()!@#&loadAPI(shell.dir()..'lgrub.sys/api/lgrub.lua') -- an interface that allows OSes to list other OSes by name, and also what we use here.!@#&loadAPI(shell.dir()..'lgrub.sys/api/Drawing.lua') -- Oeed's drawing API!@#&--loadAPI(shell.dir()..'lgrub.sys/api/wrappedFS.lua') -- forces relative paths (hopefully)!@#&--fs = wrappedFS -- Replace the standard fs with wrappedFS!@#&-- ^^ Not yet functional, but planned!@#&lgrub.init(shell)!@#&Drawing.Clear()!@#&Drawing.DrawArea(1, 1, Drawing.Screen.Width, 1, ' ', colors.lightGray, colors.lightGray)!@#&Drawing.DrawCharactersCenter(nil, 1, nil, 1, 'LuaGrub v'..lgrub.version, colors.black, colors.lightGray)!@#&Drawing.DrawBuffer()!@#&!@#&-- event spam!@#&function grub_evnt()!@#&  while true do!@#&    if __GRUB_TIME_LEFT == 'infinity' then!@#&      coroutine.yield()!@#&    else!@#&      os.queueEvent('GRUBNULLEVENT')!@#&      sleep(.25)!@#&    end!@#&  end!@#&end!@#&!@#&-- timer!@#&local function grub_countdown(e)!@#&  if __GRUB_TIME_LEFT == 'infinity' then return end!@#&  __GRUB_RUN_TIME = os.clock() - __GRUB_START_TIME!@#&  if e == 'key' then!@#&    __GRUB_TIME_LEFT = 'infinity'!@#&  else!@#&  	__GRUB_TIME_LEFT = math.floor(__GRUB_COUNTDOWN_TIME - __GRUB_RUN_TIME)!@#&  end!@#&end!@#&!@#&-- main loop!@#&local function grub_selector()!@#&  local tOS = lgrub.listOSes()!@#&  local nTermX, nTermY = term.getSize()!@#&  local sSeparator = (' '):rep(nTermX) -- Create a separator string with the size of the terminal!@#&  local continue = true!@#&  local nSelection = 1 -- The current selection defaults at 1!@#&  __GRUB_START_TIME = os.clock()!@#&  grub_countdown('sleep')!@#&  while continue do!@#&    Drawing.DrawArea(1, 1, Drawing.Screen.Width, 1, ' ', colors.lightGray, colors.lightGray)!@#&    Drawing.DrawCharactersCenter(nil, 1, nil, 1, 'LuaGrub v'..lgrub.version, colors.black, colors.lightGray)!@#&    Drawing.DrawArea(1, Drawing.Screen.Height, Drawing.Screen.Width, 1, ' ', colors.lightGray, colors.lightGray)!@#&    Drawing.DrawCharactersCenter(nil, Drawing.Screen.Height, nil, 1, __GRUB_TIME_LEFT..' seconds left to decide', colors.black, colors.lightGray)!@#&    for nLine = 1, #tOS do!@#&      local sLine = ' '!@#&      local fgColor = colors.white!@#&      if nSelection == nLine then!@#&        sLine = '>'!@#&        fgColor = colors.yellow!@#&      end!@#&      sLine = sLine..tOS[nLine][1]!@#&      Drawing.WriteStringToBuffer(2, nLine + 1, sLine, fgColor, colors.black)!@#&    end!@#&    Drawing.DrawBuffer()!@#&    local sEvent, nKey = __tempPEStorage()!@#&    if sEvent == 'key' then!@#&      grub_countdown('key')!@#&      if nKey == 200 or nKey == 17 then!@#&        if tOS[nSelection - 1] then!@#&          nSelection = nSelection - 1!@#&        else!@#&          nSelection = #tOS!@#&        end!@#&      elseif nKey == 208 or nKey == 31  then!@#&        if tOS[nSelection + 1] then!@#&          nSelection = nSelection + 1!@#&        else!@#&          nSelection = 1!@#&        end!@#&      elseif nKey == 28 then!@#&        if tOS[nSelection][2] then!@#&          continue = false!@#&        else!@#&          error('Error: Selection out of bounds: '..nSelection..'/'..#tOS)!@#&          nSelection = 1!@#&        end!@#&      end!@#&    else!@#&      grub_countdown('sleep')!@#&    end!@#&    if __GRUB_TIME_LEFT == 0 then!@#&      lgrub.prepForRun(tOS[nSelection][2])!@#&      return!@#&    end!@#&  end!@#&  lgrub.prepForRun(tOS[nSelection][2])!@#&end!@#&!@#&-- exec timer/main loop!@#&!@#&parallel.waitForAny(grub_selector, grub_evnt) -- Wait up to fifteen seconds for user input, or use the first OS in the list!@#&local __osPath = lgrub.getPrepped()!@#&!@#&-- exec OS!@#&local __continue = true!@#&while __continue do!@#&  __continue = false -- default is to shutdown after os ends, if they haven't already!@#&  if __osPath == 'CraftOS' then -- enable CraftOS support; not a boot option, must be enabled by OS!@#&    term.clear()!@#&    return -- end now, but without shutdown!@#&  end!@#&  if __osPath == 'Shutdown' then -- force immediate power down!@#&    os.shutdown()!@#&  end!@#&  os.pullEvent = __tempPEStorage -- Restore os.pullEvent to prevent possible conflicts!@#&  lgrub.run(__osPath..'/startup')!@#&  os.pullEvent = os.pullEventRaw -- Prevent ctrl-t again!@#&  if lgrub.goAgain() then!@#&    __osPath = lgrub.getNewOS()!@#&    __continue = true!@#&    lgrub.done()!@#&  end!@#&end!@#&-- power down!@#&os.shutdown() -- This is always skipped for CraftOS, and usually won't be run ever, unless the OS forgets to power down. This helps prevent hacking/mistakes.",["lgrub.sys"]={["api"]={["Drawing.lua"]="-- Written by oeed as part of OneOS!@#&!@#&local round = function(num, idp)!@#&  local mult = 10^(idp or 0)!@#&  return math.floor(num * mult + 0.5) / mult!@#&end!@#&!@#&local _w, _h = term.getSize()!@#&!@#&Screen = {!@#&  Width = _w,!@#&  Height = _h!@#&}!@#&!@#&colours.transparent = -1!@#&colors.transparent = -1!@#&!@#&DrawCharacters = function (x, y, characters, textColour, bgColour)!@#&  Drawing.WriteStringToBuffer(x, y, characters, textColour, bgColour)!@#&end!@#&!@#&DrawBlankArea = function (x, y, w, h, colour)!@#&  Drawing.DrawArea (x, y, w, h, ' ', 1, colour)!@#&end!@#&!@#&DrawArea = function (x, y, w, h, character, textColour, bgColour)!@#&  --width must be greater than 1, otherwise we get a stack overflow!@#&  if w < 0 then!@#&    w = w * -1!@#&  elseif w == 0 then!@#&    w = 1!@#&  end!@#&!@#&  for ix = 1, w do!@#&    local currX = x + ix - 1!@#&    for iy = 1, h do!@#&      local currY = y + iy - 1!@#&      Drawing.WriteToBuffer(currX, currY, character, textColour, bgColour)!@#&    end!@#&  end!@#&end!@#&!@#&DrawImage = function(_x,_y,tImage, w, h)!@#&  if tImage then!@#&    for y = 1, h do!@#&      if not tImage[y] then!@#&        break!@#&      end!@#&      for x = 1, w do!@#&        if not tImage[y][x] then!@#&          break!@#&        end!@#&        local bgColour = tImage[y][x]!@#&              local textColour = tImage.textcol[y][x] or colours.white!@#&              local char = tImage.text[y][x]!@#&              Drawing.WriteToBuffer(x+_x-1, y+_y-1, char, textColour, bgColour)!@#&      end!@#&    end!@#&  elseif w and h then!@#&    Drawing.DrawBlankArea(_x, _y, w, h, colours.lightGrey)!@#&  end!@#&end!@#&!@#&--using .nft!@#&LoadImage = function(path, global)!@#&  local image = {!@#&    text = {},!@#&    textcol = {}!@#&  }!@#&  if fs.exists(path) then!@#&    local _io = io!@#&    if OneOS then!@#&      _io = OneOS.IO!@#&    end!@#&        local file = _io.open(path, 'r')!@#&        local sLine = file:read()!@#&        local num = 1!@#&        while sLine do  !@#&            table.insert(image, num, {})!@#&            table.insert(image.text, num, {})!@#&            table.insert(image.textcol, num, {})!@#&                                        !@#&            --As we're no longer 1-1, we keep track of what index to write to!@#&            local writeIndex = 1!@#&            --Tells us if we've hit a 30 or 31 (BG and FG respectively)- next char specifies the curr colour!@#&            local bgNext, fgNext = false, false!@#&            --The current background and foreground colours!@#&            local currBG, currFG = nil,nil!@#&            for i=1,#sLine do!@#&                    local nextChar = string.sub(sLine, i, i)!@#&                    if nextChar:byte() == 30 then!@#&                            bgNext = true!@#&                    elseif nextChar:byte() == 31 then!@#&                            fgNext = true!@#&                    elseif bgNext then!@#&                            currBG = Drawing.GetColour(nextChar)!@#&                        if currBG == nil then!@#&                          currBG = colours.transparent!@#&                        end!@#&                            bgNext = false!@#&                    elseif fgNext then!@#&                            currFG = Drawing.GetColour(nextChar)!@#&                        if currFG == nil or currFG == colours.transparent then!@#&                          currFG = colours.white!@#&                        end!@#&                            fgNext = false!@#&                    else!@#&                            if nextChar ~= ' ' and currFG == nil then!@#&                                    currFG = colours.white!@#&                            end!@#&                            image[num][writeIndex] = currBG!@#&                            image.textcol[num][writeIndex] = currFG!@#&                            image.text[num][writeIndex] = nextChar!@#&                            writeIndex = writeIndex + 1!@#&                    end!@#&            end!@#&            num = num+1!@#&            sLine = file:read()!@#&        end!@#&        file:close()!@#&    else!@#&      return nil!@#&  end!@#&  return image!@#&end!@#&!@#&DrawCharactersCenter = function(x, y, w, h, characters, textColour,bgColour)!@#&  w = w or Drawing.Screen.Width!@#&  h = h or Drawing.Screen.Height!@#&  x = x or 0!@#&  y = y or 0!@#&  x = math.floor((w - #characters) / 2) + x!@#&  y = math.floor(h / 2) + y!@#&!@#&  Drawing.DrawCharacters(x, y, characters, textColour, bgColour)!@#&end!@#&!@#&GetColour = function(hex)!@#&  if hex == ' ' then!@#&    return colours.transparent!@#&  end!@#&    local value = tonumber(hex, 16)!@#&    if not value then return nil end!@#&    value = math.pow(2,value)!@#&    return value!@#&end!@#&!@#&Clear = function (_colour)!@#&  _colour = _colour or colours.black!@#&  --[[!@#&Drawing.ClearBuffer()!@#&]]--!@#&  Drawing.DrawBlankArea(1, 1, Drawing.Screen.Width, Drawing.Screen.Height, _colour)!@#&end!@#&!@#&Buffer = {}!@#&BackBuffer = {}!@#&!@#&DrawBuffer = function()!@#&  for y,row in pairs(Drawing.Buffer) do!@#&    for x,pixel in pairs(row) do!@#&      local shouldDraw = true!@#&      local hasBackBuffer = true!@#&      if Drawing.BackBuffer[y] == nil or Drawing.BackBuffer[y][x] == nil or #Drawing.BackBuffer[y][x] ~= 3 then!@#&        hasBackBuffer = false!@#&      end!@#&      if hasBackBuffer and Drawing.BackBuffer[y][x][1] == Drawing.Buffer[y][x][1] and Drawing.BackBuffer[y][x][2] == Drawing.Buffer[y][x][2] and Drawing.BackBuffer[y][x][3] == Drawing.Buffer[y][x][3] then!@#&        shouldDraw = false!@#&      end!@#&      if shouldDraw then!@#&        term.setBackgroundColour(pixel[3])!@#&        term.setTextColour(pixel[2])!@#&        term.setCursorPos(x, y)!@#&        term.write(pixel[1])!@#&      end!@#&    end!@#&  end!@#&  Drawing.BackBuffer = Drawing.Buffer!@#&  Drawing.Buffer = {}!@#&end!@#&!@#&ClearBuffer = function()!@#&  Drawing.Buffer = {}!@#&end!@#&!@#&WriteStringToBuffer = function (x, y, characters, textColour,bgColour)!@#&  for i = 1, #characters do!@#&      local character = characters:sub(i,i)!@#&      Drawing.WriteToBuffer(x + i - 1, y, character, textColour, bgColour)!@#&  end!@#&end!@#&!@#&WriteToBuffer = function(x, y, character, textColour,bgColour)!@#&  x = round(x)!@#&  y = round(y)!@#&  if bgColour == colours.transparent then!@#&    Drawing.Buffer[y] = Drawing.Buffer[y] or {}!@#&    Drawing.Buffer[y][x] = Drawing.Buffer[y][x] or {'', colours.white, colours.black}!@#&    Drawing.Buffer[y][x][1] = character!@#&    Drawing.Buffer[y][x][2] = textColour!@#&  else!@#&    Drawing.Buffer[y] = Drawing.Buffer[y] or {}!@#&    Drawing.Buffer[y][x] = {character, textColour, bgColour}!@#&  end!@#&end",["lgrub.lua"]="version = '1.0.0'!@#&enabled = true -- For OSes to see if we exist; will be true if lgrub is present, otherwise nil!@#&!@#&local shell, grubDir, tempOS, newOS!@#&local cont = false -- been having weird problems with public variables, had to wrap them in functions!@#&!@#&function bootNewOS(osName)!@#&  newOS = osName!@#&  cont = true!@#&end!@#&!@#&function rebootOS()!@#&  cont = true!@#&end!@#&!@#&function listOSes() -- This is a public function because OSes might allow the installation of new OSes. After a new one is installed, they should run this.!@#&  local dirs = fs.list(osDir)!@#&  local tOut = {}!@#&  local sData!@#&  for i, dir in ipairs(dirs) do!@#&    dir = osDir..'/'..dir!@#&    local items = fs.list(dir)!@#&    if fs.isDir(dir) then!@#&      if fs.exists(dir..'/name.grub') then -- they have declared their name!@#&        local file = fs.open(dir..'/name.grub', 'r')!@#&        sData = file.readLine() -- We get their actual name!@#&        file.close()!@#&        tOut[#tOut+1] = { sData, dir }!@#&      else -- They didn't declare their name, so we assume it's the same as the directory they're in!@#&        tOut[#tOut+1] = { dir, dir }!@#&      end!@#&    end!@#&  end!@#&  table.insert(tOut,{'Shutdown', 'Shutdown'})!@#&  return tOut!@#&end!@#&!@#&function run(osName)!@#&  term.setCursorPos(1,1)!@#&  term.setTextColor(colors.white)!@#&  term.setBackgroundColor(colors.black)!@#&  term.clear()!@#&  shell.run(osName)!@#&  term.clear()!@#&end!@#&!@#&local function setShell( t )!@#&  shell = t!@#&  grubDir = shell.dir()!@#&  osDir = grubDir..'/os'!@#&end!@#&!@#&function init(shellRef)!@#&  setShell(shellRef or shell)!@#&  if not shell then!@#&    error('Must pass a shell reference at least once')!@#&  end!@#&end!@#&!@#&-- ignore everything below here; using them could break things!@#&!@#&function prepForRun(path)!@#&  tempOS = path!@#&end!@#&!@#&function getPrepped()!@#&  return tempOS!@#&end!@#&!@#&function done()!@#&  cont = false!@#&end!@#&!@#&function goAgain()!@#&  return cont!@#&end!@#&!@#&function getNewOS()!@#&  return newOS!@#&end",["wrappedFS.lua"]="fs2 = fs!@#&!@#&-- run 'fs = wrappedFS' after 'os.loadAPI'!@#&!@#&function open(path, mode)!@#&  !@#&end!@#&!@#&--TODO actually write the wrappedFS API",},},} local function makeFile(_path, _content) local file = fs.open(_path, "w") _content = _content:gsub("!@".."#&", "%\n") _content = textutils.unserialize(_content) file.write(_content) file.close() end local function makeFolder(_path, _content) fs.makeDir(_path) for k,v in pairs(_content) do if type(v) == "table" then makeFolder(_path .. "/" .. k, v) else makeFile(_path .. "/" .. k, v) end end end local sDest = shell.resolve( "root" ) or "/" if sDest == "root" then sDest = "/" end local tPackage = pkg makeFolder(sDest, tPackage) print("Package Extracted to '" .. sDest .. "'!") sleep(1.5) fs.delete(shell.resolve(shell.getRunningProgram())) os.reboot()
